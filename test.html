<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Level-2-1</title>

    <style>
        html,body{
            overflow: hidden;
            width:100%;
            height: 100%;
            margin:0;
            padding: 0;
        }
        #renderCanvas{
            width:100%;
            height: 100%;
            touch-action: none;
        }
    </style>
    <script src="/node_modules/_earcut@2.1.3@earcut/dist/earcut.min.js"></script>
    <script src="/node_modules/babylonjs/babylon.js"></script>
    <script src="/node_modules/babylonjs/Oimo.js"></script>
    <script src="/node_modules/_babylonjs-gui@3.3.0@babylonjs-gui/babylon.gui.min.js"></script>

</head>
<body>

    <canvas id="renderCanvas"></canvas>

    <script>
       

        var canvas=document.getElementById("renderCanvas");
        var engine =new BABYLON.Engine(canvas,true);
        var up;
        var getAllmeshid;
        var createScene = function () {

        var scene = new BABYLON.Scene(engine); 
        scene.clearColor = new BABYLON.Color3(0.5, 0.5, 0.5);

        // camera
        var camera = new BABYLON.ArcRotateCamera("camera1", 0, 0, 0, new BABYLON.Vector3(0, 0, 0), scene);
        
        camera.setPosition(new BABYLON.Vector3(0, 10, -21.5));
        // var camera=new BABYLON.FreeCamera("camera1",new BABYLON.Vector3(0,5,-10),scene);//创建和放置自由相机

        camera.attachControl(canvas, true);
        // lights
        
        var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(10, -10, 0), scene);
        var light = new BABYLON.HemisphericLight("light2", new BABYLON.Vector3(10, 10, 0), scene);

        light.intensity = 0.9;
        
 

        //创建地面
        // var ground = BABYLON.Mesh.CreateGround("ground1",30,25,2,scene);
        // var materialGround = new BABYLON.StandardMaterial("texture1", scene);
        // materialGround.material = materialGround;
        // materialGround.alpha = 1;
        // materialGround.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
        // materialGround.diffuseTexture = new BABYLON.Texture("../pic/ground.jpg", scene);
        // ground.material = materialGround;



        //building house
       
        var wallmat = new BABYLON.StandardMaterial("wallmaterial", scene);
        wallmat.diffuseTexture = new BABYLON.Texture("../pic/2b1C7UH.jpg", scene);
        	
        var innerwallmat = new BABYLON.StandardMaterial("innerwallmaterial", scene);
        innerwallmat.diffuseColor = new BABYLON.Color3(240/255, 223/255, 203/255);



	    //Polygon shape in XoZ plane
        var frontWallData = [ 
        				new BABYLON.Vector3(-5.5, 0, -3), 
                        new BABYLON.Vector3(-0.5, 0, -3), 
                        new BABYLON.Vector3(-0.5, 0, -0.75), 
                        new BABYLON.Vector3(0.5, 0, -0.75), 
                        new BABYLON.Vector3(0.5, 0, -3),
                        new BABYLON.Vector3(5.5, 0, -3), 
                        new BABYLON.Vector3(5.5, 0, 3), 
                        new BABYLON.Vector3(-5.5, 0, 3)
                      ];

        //Holes in XoZ plane 窗户洞
        var frontWindowHoles = [];
        		frontWindowHoles[0] = [ 
        				new BABYLON.Vector3(-4.78, 0, -2.3),
                        new BABYLON.Vector3(-1.58, 0, -2.3),
                        new BABYLON.Vector3(-1.58, 0, -0.3),
                        new BABYLON.Vector3(-4.78, 0, -0.3)
                       ];
        		frontWindowHoles[1] = [ 
                        new BABYLON.Vector3(1.58, 0, -2.3),
        				new BABYLON.Vector3(4.78, 0, -2.3),
        				new BABYLON.Vector3(4.78, 0, -0.3),
                        new BABYLON.Vector3(1.58, 0, -0.3)
                       ];
               frontWindowHoles[2] = [ 
        				new BABYLON.Vector3(-4.03, 0, 0.75),
                        new BABYLON.Vector3(-2.13, 0, 0.75),
                        new BABYLON.Vector3(-2.13, 0, 2.55),
                        new BABYLON.Vector3(-4.03, 0, 2.55)
                       ]; 
        		frontWindowHoles[3] = [ 
        				new BABYLON.Vector3(-0.65, 0, 0.75),
                        new BABYLON.Vector3(0.65, 0, 0.75),
                        new BABYLON.Vector3(0.65, 0, 2.55),
                        new BABYLON.Vector3(-0.65, 0, 2.55)
                       ];	   
               frontWindowHoles[4] = [ 
        				new BABYLON.Vector3(2.13, 0, 0.75),
                        new BABYLON.Vector3(4.03, 0, 0.75),
                        new BABYLON.Vector3(4.03, 0, 2.55),
                        new BABYLON.Vector3(2.13, 0, 2.55)
                       ];   


            var faceUV = new Array(3);
        	faceUV[0] = new BABYLON.Vector4(0, 0, 7/15, 1);
        	faceUV[1] = new BABYLON.Vector4(14/15, 0, 1, 1);
        	faceUV[2] = new BABYLON.Vector4(7/15, 0, 14/15, 1);
           
            //前墙面
            var frontWall = BABYLON.MeshBuilder.ExtrudePolygon("wall", {shape:frontWallData, depth: 0.15, holes:frontWindowHoles, faceUV: faceUV}, scene);
        	frontWall.rotation.x = -Math.PI/2;
        	frontWall.material = wallmat;

            frontWall.setAbsolutePosition(new BABYLON.Vector3(0,0,-10));





            var rearWallnb1Data = [ 
        				new BABYLON.Vector3(1.4, 0, -3), 
                        new BABYLON.Vector3(5.5, 0, -3), 
                        new BABYLON.Vector3(5.5, 0, 3), 
                        new BABYLON.Vector3(1.4, 0, 3)
                      ];

            //Holes in XoZ plane
        	var rear1WindowHoles = [];
        		rear1WindowHoles[0] = [ 
        				new BABYLON.Vector3(3.7, 0, -1.8),
                        new BABYLON.Vector3(4.5, 0, -1.8),
                        new BABYLON.Vector3(4.5, 0, -0.3),
                        new BABYLON.Vector3(3.7, 0, -0.3)
                       ];
        		rear1WindowHoles[1] = [ 
        				new BABYLON.Vector3(1.9, 0, 0.75),
                        new BABYLON.Vector3(2.7, 0, 0.75),
                        new BABYLON.Vector3(2.7, 0, 2.55),
                        new BABYLON.Vector3(1.9, 0, 2.55)
                       ];
        		rear1WindowHoles[2] = [ 
        				new BABYLON.Vector3(4.2, 0, 0.75),
                        new BABYLON.Vector3(5, 0, 0.75),
                        new BABYLON.Vector3(5, 0, 2.55),
                        new BABYLON.Vector3(4.2, 0, 2.55)
                       ];
        
        	var rearFaceUV = [];
        	rearFaceUV[0] = new BABYLON.Vector4(7/15, 0, 14/15, 1);
        	rearFaceUV[1] = new BABYLON.Vector4(14/15, 0, 1, 1);
        	rearFaceUV[2] = new BABYLON.Vector4(0, 0, 7/15, 1);

            //后墙面1
            var rearWallnb1 = BABYLON.MeshBuilder.ExtrudePolygon("rearWallnb1", {shape:rearWallnb1Data, depth: 0.1, holes: rear1WindowHoles, faceUV: rearFaceUV}, scene);
        	rearWallnb1.rotation.x = -Math.PI/2;
        	rearWallnb1.position.z = 6.15;	
        	rearWallnb1.material = wallmat;

            rearWallnb1.setAbsolutePosition(new BABYLON.Vector3(0,0,20));

            var rearWallnb2Data = [ 
        				new BABYLON.Vector3(-5.6, 0, -3), 
                        new BABYLON.Vector3(1.45, 0, -3), 
                        new BABYLON.Vector3(1.45, 0, 3), 
                        new BABYLON.Vector3(-2.075, 0, 5.5), 
                        new BABYLON.Vector3(-5.6, 0, 3)
                      ];
        			  
        
        	var rear2WindowHoles = [];
        		rear2WindowHoles[0] = [ 
        				new BABYLON.Vector3(-5, 0, -1.8),
                        new BABYLON.Vector3(-1.85, 0, -1.8),
                        new BABYLON.Vector3(-1.85, 0, -0.3),
                        new BABYLON.Vector3(-5, 0, -0.3)
                       ];
        		rear2WindowHoles[1] = [ 
        				new BABYLON.Vector3(-0.8, 0, -1.8),
                        new BABYLON.Vector3(0.9, 0, -1.8),
                        new BABYLON.Vector3(0.9, 0, -0.3),
                        new BABYLON.Vector3(-0.8, 0, -0.3)
                       ];	   
        		rear2WindowHoles[2] = [ 
        				new BABYLON.Vector3(-5, 0, 0.75),
                        new BABYLON.Vector3(-1.85, 0, 0.75),
                        new BABYLON.Vector3(-1.85, 0, 2.55),
                        new BABYLON.Vector3(-5, 0, 2.55)
                       ];
        		rear2WindowHoles[3] = [ 
        				new BABYLON.Vector3(-0.6, 0, 1.75),
                        new BABYLON.Vector3(0.7, 0, 1.75),
                        new BABYLON.Vector3(0.7, 0, 2.55),
                        new BABYLON.Vector3(-0.6, 0, 2.55)
                       ];	   
        	//后墙面2									 
        	var rearWallnb2 = BABYLON.MeshBuilder.ExtrudePolygon("rearWallnb2", {shape:rearWallnb2Data, holes: rear2WindowHoles, depth: 0.1, faceUV: rearFaceUV}, scene);
        	rearWallnb2.rotation.x = -Math.PI/2;
        	rearWallnb2.position.z = 9.15;
        	
        	rearWallnb2.material = wallmat;
            rearWallnb2.setAbsolutePosition(new BABYLON.Vector3(-5,0,20));


            var sideWallnb1Data = [ 
        			new BABYLON.Vector3(-3.15, 0, -3), 
                    new BABYLON.Vector3(3.1, 0, -3), 
                    new BABYLON.Vector3(3.1, 0, 3), 
                    new BABYLON.Vector3(0, 0, 5.5), 
                    new BABYLON.Vector3(-3.15, 0, 3)
                ];
        	   
        	var side1FaceUV = new Array(3);
        	
        	side1FaceUV[0] = new BABYLON.Vector4(0, 0, 7/15, 1);
        	side1FaceUV[1] = new BABYLON.Vector4(14/15, 0, 1, 1);
        	side1FaceUV[2] = new BABYLON.Vector4(7/15, 0, 14/15, 1);
        	//右墙面1
        	var sideWallnb1 = BABYLON.MeshBuilder.ExtrudePolygon("sideWallnb1", {shape:sideWallnb1Data, depth: 0.1, faceUV: side1FaceUV}, scene);
        	sideWallnb1.rotation.z = -Math.PI/2;
        	sideWallnb1.rotation.x = -Math.PI/2;
        	sideWallnb1.position.x = 5.6;
        	sideWallnb1.position.z = 3.15;
        	
        	sideWallnb1.material = wallmat;
            sideWallnb1.setAbsolutePosition(new BABYLON.Vector3(15,0, 3.15));


            var sideWallnb2Data = [ 
        			new BABYLON.Vector3(-3.15, 0, -3), 
                    new BABYLON.Vector3(6, 0, -3), 
                    new BABYLON.Vector3(6, 0, 3), 
        			new BABYLON.Vector3(3.1, 0, 3),
                    new BABYLON.Vector3(0, 0, 5.5), 
        			new BABYLON.Vector3(-3.15, 0, 3)
                ];
        	
        	var side2FaceUV = new Array(3);
        	
        	side2FaceUV[0] = new BABYLON.Vector4(7/15, 0, 14/15, 1);
        	side2FaceUV[1] = new BABYLON.Vector4(14/15, 0, 1, 1);
        	side2FaceUV[2] = new BABYLON.Vector4(0, 0, 7/15, 1)	
        	//左墙面1										 
        	var sideWallnb2 = BABYLON.MeshBuilder.ExtrudePolygon("sideWallnb2", {shape:sideWallnb2Data, depth: 0.1, faceUV: side2FaceUV}, scene);
        	sideWallnb2.rotation.z = -Math.PI/2;
        	sideWallnb2.rotation.x = -Math.PI/2;
        	sideWallnb2.position.x = -5.5;
        	sideWallnb2.position.z = 3.15;
        	sideWallnb2.material = wallmat;

            sideWallnb2.setAbsolutePosition(new BABYLON.Vector3(-15,0, 3.15));



            var sideWallnb3Data = [ 
        			new BABYLON.Vector3(3.1, 0, -3),
        			new BABYLON.Vector3(4.5, 0, -3),
        			new BABYLON.Vector3(4.5, 0, -0.75),
        			new BABYLON.Vector3(5.5, 0, -0.75),
        			new BABYLON.Vector3(5.5, 0, -3),
                    new BABYLON.Vector3(6, 0, -3), 
                    new BABYLON.Vector3(6, 0, 3),  
                    new BABYLON.Vector3(3.1, 0, 3)
                ];	
        	   
        	var side3FaceUV = new Array(3);
        	
        	side3FaceUV[0] = new BABYLON.Vector4(0, 0, 7/15, 1);
        	side3FaceUV[1] = new BABYLON.Vector4(14/15, 0, 1, 1);
        	side3FaceUV[2] = new BABYLON.Vector4(7/15, 0, 14/15, 1);
        	//右边墙面3
        	var sideWallnb3 = BABYLON.MeshBuilder.ExtrudePolygon("sideWallnb3", {shape:sideWallnb3Data, depth: 0.1, faceUV: side3FaceUV}, scene);
        	sideWallnb3.rotation.z = -Math.PI/2;
        	sideWallnb3.rotation.x = -Math.PI/2;
        	sideWallnb3.position.x = 1.45;
        	sideWallnb3.position.z = 3.15;
        	
        	sideWallnb3.material = wallmat;
    
            var roofmat = new BABYLON.StandardMaterial("roofmat", scene);
        	roofmat.diffuseTexture = new BABYLON.Texture("../pic/Vw4fzwq.jpg", scene);
        
        	var roof1Data = [
        		new BABYLON.Vector3(-0.05, 0, 0),
        		new BABYLON.Vector3(0.1, 0, 0),
        		new BABYLON.Vector3(3.3, 0, 2.65),
        		new BABYLON.Vector3(6.5, 0, 0),
        		new BABYLON.Vector3(6.6, 0, 0),
        		new BABYLON.Vector3(3.3, 0, 2.8)
        	];
        	//屋顶1 前屋顶
        	var roof1 = BABYLON.MeshBuilder.ExtrudePolygon("roof1", {shape:roof1Data, depth: 11.5}, scene);
        	roof1.rotation.z = -Math.PI/2;
        	roof1.rotation.x = -Math.PI/2;
        	roof1.position.x = 5.7;
        	roof1.position.y = 2.9;
        	roof1.position.z = -0.15;
        	roof1.material = roofmat;
            roof1.setAbsolutePosition(new BABYLON.Vector3(5.7, 5, -0.15));


            //后屋顶1
            var roof2Data = [
        		new BABYLON.Vector3(0, 0, 0),
        		new BABYLON.Vector3(0.142, 0, 0),
        		new BABYLON.Vector3(3.834, 0, 2.6),
        		new BABYLON.Vector3(7.476, 0, 0),
        		new BABYLON.Vector3(7.618, 0, 0),
        		new BABYLON.Vector3(3.834, 0, 2.7) 
        	];
        	
        	var roof2 = BABYLON.MeshBuilder.ExtrudePolygon("roof2", {shape:roof2Data, depth: 3.2}, scene);
        	roof2.rotation.x = -Math.PI/2;
        	roof2.position.x = -5.9;
        	roof2.position.y = 2.9;
        	roof2.position.z = 6.3;
        	
        	roof2.material = roofmat;
            roof2.setAbsolutePosition(new BABYLON.Vector3(-5.9, 5, 6.3));



            var roof3Data = [
        		new BABYLON.Vector3(0.3, 0, 0.2),
        		new BABYLON.Vector3(0.442, 0, 0.2),
        		new BABYLON.Vector3(3.834, 0, 2.6),
        		new BABYLON.Vector3(7.476, 0, 0),
        		new BABYLON.Vector3(7.618, 0, 0),
        		new BABYLON.Vector3(3.834, 0, 2.7) 
        	];
        	//后屋顶2
        	var roof3 = BABYLON.MeshBuilder.ExtrudePolygon("roof3", {shape:roof3Data, depth: 3.2}, scene);
        	roof3.rotation.x = -Math.PI/2;
        	roof3.position.x = -5.9;
        	roof3.position.y = 2.9;
        	roof3.position.z = 3.1;
        	
        	roof3.material = roofmat;
            roof3.setAbsolutePosition(new BABYLON.Vector3(-5.9, 5, 3.1));
        	
        	var roof = BABYLON.Mesh.MergeMeshes([roof1, roof2, roof3], true);

            roof.setAbsolutePosition(new BABYLON.Vector3(-5.9, 5, 6.3));



            var stairsDepth = 2;
            var stairsHeight = 3.0;
            var stairsThickness = 0.05;
            var nBStairs = 12;
            var stairs = [];
            var x = 0;
            var z = 0;
            //up 楼梯
            stairs.push(new BABYLON.Vector3(x, 0, z));
            z += stairsHeight/nBStairs - stairsThickness;
            stairs.push(new BABYLON.Vector3(x, 0, z));
            for(var i = 0; i<nBStairs; i++) {
                x += stairsDepth/nBStairs;
                stairs.push(new BABYLON.Vector3(x, 0, z));
                z += stairsHeight/nBStairs;
                stairs.push(new BABYLON.Vector3(x, 0, z));
            }
            x += stairsDepth/nBStairs - stairsThickness;
            stairs.push(new BABYLON.Vector3(x, 0, z));

            //down
            for(var i = 0; i<=nBStairs; i++) {
                x -= stairsDepth/nBStairs
                stairs.push(new BABYLON.Vector3(x, 0, z));
                z -= stairsHeight/nBStairs;
                stairs.push(new BABYLON.Vector3(x, 0, z));
            }
        	
        	faceColors = [];
        	faceColors[0] = new BABYLON.Color4(0, 0, 0, 1);
        	faceColors[1] = new BABYLON.Color4(190/255, 139/255, 94/255, 1);
        	faceColors[2] = new BABYLON.Color4(0, 0, 0, 1);
        
            var stairsWidth = 1.0;
            var stairCase = BABYLON.MeshBuilder.ExtrudePolygon("stairs", {shape:stairs, depth: stairsWidth, faceColors: faceColors}, scene);
        	stairCase.position.x = 1.37;
            stairCase.position.y = -3.0;
            stairCase.position.z = 2.51;
            stairCase.rotation.x = -Math.PI/2;
            stairCase.rotation.y = -Math.PI/2;

            //二楼地板
            var floormat = new BABYLON.StandardMaterial("floormaterial", scene);
            floormat.diffuseTexture = new BABYLON.Texture(
                "../pic/DRSozlo.jpg",
                scene);

                var floorData = [ 
        					new BABYLON.Vector3(-5.5, 0, 0),					
                            new BABYLON.Vector3(5.5, 0, 0),
                            new BABYLON.Vector3(5.5, 0, 6),
        					new BABYLON.Vector3(1.345, 0, 6),
        					new BABYLON.Vector3(1.345, 0, 9),
                            new BABYLON.Vector3(-5.5, 0, 9)
                      ];
        			  
        	var stairSpace = [];
        	stairSpace[0] = [
        					new BABYLON.Vector3(0.27, 0, 2.5),
        					new BABYLON.Vector3(0.27, 0, 4.5),
        					new BABYLON.Vector3(1.37, 0, 4.5),
        					new BABYLON.Vector3(1.37, 0, 2.5),
        				]
        			  
        	var floorFaceUV = new Array(3);
        	
        	floorFaceUV[0] = new BABYLON.Vector4(0, 0, 0.5, 1);
        	floorFaceUV[2] = new BABYLON.Vector4(0.5, 0, 1, 1);
        	
        
        	var floor = BABYLON.MeshBuilder.ExtrudePolygon("floor", {shape:floorData, holes:stairSpace, depth: 0.1, faceUV: floorFaceUV}, scene);
        	floor.position.y = 0.21;
        	floor.position.z = 0.15;
        	
        	floor.material = floormat;
            
            
            var groundFloorData = [ 
        					new BABYLON.Vector3(-5.6, 0, -0.1),					
                            new BABYLON.Vector3(5.6, 0, -0.1),
                            new BABYLON.Vector3(5.6, 0, 6.1),
        					new BABYLON.Vector3(1.36, 0, 6.1),
        					new BABYLON.Vector3(1.36, 0, 9.1),
                            new BABYLON.Vector3(-5.6, 0, 9.1)
                      ];
        			  
        	var groundFloorFaceUV = new Array(3);
        	
        	groundFloorFaceUV[0] = new BABYLON.Vector4(0, 0, 0.5, 1);
        	groundFloorFaceUV[2] = new BABYLON.Vector4(0.5, 0, 1, 1);
        	
            //一楼地板
        	var groundFloor = BABYLON.MeshBuilder.ExtrudePolygon("groundFloor", {shape:groundFloorData, depth: 0.04, faceUV: groundFloorFaceUV}, scene);
        	groundFloor.position.y = -3;
        	groundFloor.position.z = 0.15;
        	groundFloor.material = floormat;

            var ceilingData = [ 
        					new BABYLON.Vector3(-5.5, 0, 0),					
                            new BABYLON.Vector3(5.5, 0, 0),
                            new BABYLON.Vector3(5.5, 0, 6),
        					new BABYLON.Vector3(1.345, 0, 6),
        					new BABYLON.Vector3(1.345, 0, 9),
                            new BABYLON.Vector3(-5.5, 0, 9)
                      ];
        			  
        	
            //天花板
        	var ceiling = BABYLON.MeshBuilder.ExtrudePolygon("ceiling", {shape:ceilingData, depth: 0.1}, scene);
        	ceiling.position.y = 2.8;
        	ceiling.position.z = 0.15;
        	
        	ceiling.material = innerwallmat;

            var innerWallnb1Data = [
        						new BABYLON.Vector3(-3, 0, 0.6),
        						new BABYLON.Vector3(-3, 0, 0),
        						new BABYLON.Vector3(3, 0, 0),
        						new BABYLON.Vector3(3, 0, 6.1),
        						new BABYLON.Vector3(-3, 0, 6.1),
        						new BABYLON.Vector3(-3, 0, 1.6),
        						new BABYLON.Vector3(-1, 0, 1.6),
        						new BABYLON.Vector3(-1, 0, 0.6),
        					];
        						 
        	var doorSpace1 = [];
        	doorSpace1[0] = [
        				new BABYLON.Vector3(0.1, 0, 1.6),
        				new BABYLON.Vector3(0.1, 0, 0.6),
        				new BABYLON.Vector3(2, 0, 0.6),
        				new BABYLON.Vector3(2, 0, 1.6)
        			];					
            //内墙1
        	var innerWallnb1 = BABYLON.MeshBuilder.ExtrudePolygon("innerWallnb1", {shape:innerWallnb1Data, holes: doorSpace1, depth: 0.1}, scene);
        	innerWallnb1.rotation.z = Math.PI/2;
        	innerWallnb1.position.x = 1.35;
        	innerWallnb1.position.z = 0.15; 
        
        	innerWallnb1.material = innerwallmat;


            var innerWallnb2Data = [
        						new BABYLON.Vector3(-3, 0, 0),
        						new BABYLON.Vector3(3, 0, 0),
        						new BABYLON.Vector3(3, 0, 9),
        						new BABYLON.Vector3(-3, 0, 9),
        						new BABYLON.Vector3(-3, 0, 7.6),
        						new BABYLON.Vector3(-1, 0, 7.6),
        						new BABYLON.Vector3(-1, 0, 6.6),
        						new BABYLON.Vector3(-3, 0, 6.6),
        						new BABYLON.Vector3(-3, 0, 1.6),
        						new BABYLON.Vector3(-1, 0, 1.6),
        						new BABYLON.Vector3(-1, 0, 0.6),
        						new BABYLON.Vector3(-3, 0, 0.6)
        						 ];
        						 
        	var doorSpace2 = [];
        	doorSpace2[0] = [
        				new BABYLON.Vector3(0.1, 0, 0.6),
        				new BABYLON.Vector3(2, 0, 0.6),
        				new BABYLON.Vector3(2, 0, 1.6),
        				new BABYLON.Vector3(0.1, 0, 1.6)
        			];
        	doorSpace2[1] = [
        				new BABYLON.Vector3(0.1, 0, 4.6),
        				new BABYLON.Vector3(2, 0, 4.6),
        				new BABYLON.Vector3(2, 0, 5.6),
        				new BABYLON.Vector3(0.1, 0, 5.6)
        			];
        			
        			
            //内墙2
        	var innerWallnb2 = BABYLON.MeshBuilder.ExtrudePolygon("innerWallnb2", {shape:innerWallnb2Data, holes: doorSpace2, depth: 0.1}, scene);
        	innerWallnb2.rotation.z = Math.PI/2;
        	innerWallnb2.position.x = 1.35;
        	innerWallnb2.position.z = 0.15;
        	innerWallnb2.position.x = -1.4;
        	
        	innerWallnb2.material = innerwallmat;


            var bathroomWallData = [
        						new BABYLON.Vector3(-1.4, 0, 0),
        						new BABYLON.Vector3(-0.5, 0, 0),
        						new BABYLON.Vector3(-0.5, 0, 2),
        						new BABYLON.Vector3(0.5, 0, 2),
        						new BABYLON.Vector3(0.5, 0, 0),
        						new BABYLON.Vector3(1.4, 0, 0),
        						new BABYLON.Vector3(1.4, 0, 6),
        						new BABYLON.Vector3(-1.4, 0, 6)
        						 ];
        						 
        	var doorSpace3 = [];
        	doorSpace3[0] = [
        				new BABYLON.Vector3(-0.5, 0, 3.2),
        				new BABYLON.Vector3(-0.5, 0, 5.2),
        				new BABYLON.Vector3(0.5, 0, 5.2),
        				new BABYLON.Vector3(0.5, 0, 3.2)
        	]					 
        										 
        
        	var bathroomWall = BABYLON.MeshBuilder.ExtrudePolygon("bathroomWall", {shape:bathroomWallData, depth: 0.1, holes: doorSpace3}, scene);
        	bathroomWall.rotation.x = -Math.PI/2;
        	bathroomWall.position.y = -3;
        	bathroomWall.position.z = 6;
        	
        	bathroomWall.material = innerwallmat;

            var bedroom1WallData = [
        						new BABYLON.Vector3(-5.5, 0, 0),
        						new BABYLON.Vector3(-2.9, 0, 0),
        						new BABYLON.Vector3(-2.9, 0, 2),
        						new BABYLON.Vector3(-1.9, 0, 2),
        						new BABYLON.Vector3(-1.9, 0, 0),
        						new BABYLON.Vector3(-1.4, 0, 0),
        						new BABYLON.Vector3(-1.4, 0, 6),
        						new BABYLON.Vector3(-5.5, 0, 6)
        					];	 
        											 
        	var bedroom1Wall = BABYLON.MeshBuilder.ExtrudePolygon("bedroom1Wall", {shape:bedroom1WallData, depth: 0.1}, scene);
        	bedroom1Wall.rotation.x = -Math.PI/2;
        	bedroom1Wall.position.y = -3;
        	bedroom1Wall.position.z = 4.5;
        	
        	bedroom1Wall.material = innerwallmat;


            var bannisterWallData = [
        						new BABYLON.Vector3(0, 0, 0),
        						new BABYLON.Vector3(1, 0, 0),
        						new BABYLON.Vector3(1, 0, 1.4),
        						new BABYLON.Vector3(1.75, 0, 1.4),
        						new BABYLON.Vector3(1.75, 0, 0),
        						new BABYLON.Vector3(3.5, 0, 0),
        						new BABYLON.Vector3(3.5, 0, 3.2),
        						new BABYLON.Vector3(1.5, 0, 3.2),
        						new BABYLON.Vector3(0, 0, 0.75)
        						];
        	var spindleThickness = 0.05;
        	var spindles = 12;
        	var railGap = (1.5 - spindles * spindleThickness)/(spindles - 1);
        	var rail = [];
        	var ac = spindleThickness;
        	for(var s = 0; s < spindles - 1; s++) {
        		rail[s] = [];
        		rail[s].push(new BABYLON.Vector3(ac, 0, 0.1 + 1.6 *ac));
        		rail[s].push(new BABYLON.Vector3(ac, 0, (0.75 - spindleThickness) + 1.6 *ac));
        		rail[s].push(new BABYLON.Vector3(ac + railGap, 0, (0.75 - spindleThickness) + 1.6 *(ac + railGap)));
        		rail[s].push(new BABYLON.Vector3(ac + railGap, 0, 1.6 *(ac + railGap)));
        		ac += spindleThickness + railGap;
        	}
        					
        	var bannisterWall = BABYLON.MeshBuilder.ExtrudePolygon("bannisterWall", {shape:bannisterWallData, holes: rail, depth: 0.1}, scene);
        	bannisterWall.rotation.x = -Math.PI/2;
        	bannisterWall.rotation.z = -Math.PI/2;
        	bannisterWall.position.x = 0.4;
        	bannisterWall.position.y = -3;
        	bannisterWall.position.z = 2.51;

            var bannister1Data = [
        						new BABYLON.Vector3(0, 0, 0),
        						new BABYLON.Vector3(2, 0, 0),
        						new BABYLON.Vector3(2, 0, 0.75),
        						new BABYLON.Vector3(0, 0, 0.75),
        						];
        	var spindle1Thickness = 0.05;
        	var spindles1 = 12;
        	var rail1Gap = (2 - spindles1 * spindle1Thickness)/(spindles1 - 1);
        	var rail1 = [];
        	var ac1 = spindle1Thickness;
        	for(var s = 0; s < spindles1 - 1; s++) {
        		rail1[s] = [];
        		rail1[s].push(new BABYLON.Vector3(ac1, 0, spindle1Thickness));
        		rail1[s].push(new BABYLON.Vector3(ac1, 0, 0.75 - spindle1Thickness));
        		rail1[s].push(new BABYLON.Vector3(ac1 + rail1Gap, 0, 0.75 - spindle1Thickness));
        		rail1[s].push(new BABYLON.Vector3(ac1 + rail1Gap, 0, spindle1Thickness));
        		ac1 += spindle1Thickness + rail1Gap;
        	}
        					
        	var bannister1 = BABYLON.MeshBuilder.ExtrudePolygon("bannister1", {shape:bannister1Data, holes: rail1, depth: 0.1}, scene);
        	bannister1.rotation.x = -Math.PI/2;
        	bannister1.rotation.z = -Math.PI/2;
        	bannister1.position.x = 0.3;
        	bannister1.position.y = 0.2;
        	bannister1.position.z = 2.61;
        	
        	var bannister2Data = [
        						new BABYLON.Vector3(0, 0, 0),
        						new BABYLON.Vector3(1, 0, 0),
        						new BABYLON.Vector3(1, 0, 0.75),
        						new BABYLON.Vector3(0, 0, 0.75),
        						];
        	var spindle2Thickness = 0.05;
        	var spindles2 = 6;
        	var rail2Gap = (1- spindles2 * spindle2Thickness)/(spindles2 - 1);
        	var rail2 = [];
        	var ac2 = spindle2Thickness;
        	for(var s = 0; s < spindles2 - 1; s++) {
        		rail2[s] = [];
        		rail2[s].push(new BABYLON.Vector3(ac2, 0, spindle2Thickness));
        		rail2[s].push(new BABYLON.Vector3(ac2, 0, 0.75 - spindle2Thickness));
        		rail2[s].push(new BABYLON.Vector3(ac2 + rail2Gap, 0, 0.75 - spindle2Thickness));
        		rail2[s].push(new BABYLON.Vector3(ac2 + rail2Gap, 0, spindle2Thickness));
        		ac2 += spindle2Thickness + rail2Gap;
        	}
        					
        	var bannister2 = BABYLON.MeshBuilder.ExtrudePolygon("bannister2", {shape:bannister2Data, holes: rail2, depth: 0.1}, scene);
        	bannister2.rotation.x = -Math.PI/2;
        	bannister2.position.x = 0.3;
        	bannister2.position.y = 0.2;
        	bannister2.position.z = 2.61; 


            var windowMaker = function(width, height, frames, frameDepth, frameThickness) {
        		var windowShape = [
        			new BABYLON.Vector3(0, 0, 0),
        			new BABYLON.Vector3(width, 0, 0),
        			new BABYLON.Vector3(width, 0, height),
        			new BABYLON.Vector3(0, 0, height)
        		];
        		var glassWidth = (width - (frames + 1) * frameThickness)/frames;
        		var glassTopHeight = height/3 - frameThickness;
        		var glassBotHeight = 2 * glassTopHeight;
        		var glass = [];
        		var acf = frameThickness;
        		for(var f = 0; f < frames; f++) {
        			glass[2*f] = [];
        			glass[2*f].push(new BABYLON.Vector3(acf, 0, 2*frameThickness + glassBotHeight));
        			glass[2*f].push(new BABYLON.Vector3(acf + glassWidth, 0, 2 * frameThickness + glassBotHeight));
        			glass[2*f].push(new BABYLON.Vector3(acf + glassWidth, 0, 2 * frameThickness + glassBotHeight + glassTopHeight));
        			glass[2*f].push(new BABYLON.Vector3(acf, 0, 2 * frameThickness + glassBotHeight + glassTopHeight));
        			glass[2*f + 1] = [];
        			glass[2*f + 1].push(new BABYLON.Vector3(acf, 0, frameThickness));
        			glass[2*f + 1].push(new BABYLON.Vector3(acf + glassWidth, 0, frameThickness));
        			glass[2*f + 1].push(new BABYLON.Vector3(acf + glassWidth, 0, frameThickness + glassBotHeight));
        			glass[2*f + 1].push(new BABYLON.Vector3(acf, 0, frameThickness + glassBotHeight));
        			acf += frameThickness + glassWidth;
        		}
        		var window = BABYLON.MeshBuilder.ExtrudePolygon("window", {shape:windowShape, holes: glass, depth: frameDepth}, scene);
        		window.rotation.x = -Math.PI/2;
        		return window;
        	}
  
            var windowFBL = windowMaker(3.2, 2, 4, 0.15, 0.1);
        	windowFBL.position.x = -4.78;
        	windowFBL.position.y = -2.3;
        	windowFBL.position.z = 0.1;
        	
        	var windowFBR = windowMaker(3.2, 2, 4, 0.15, 0.1);
        	windowFBR.position.x = 1.58;
        	windowFBR.position.y = -2.3;
        	windowFBR.position.z = 0.1;
        	
        	var windowFTL = windowMaker(1.9, 1.8, 2, 0.15, 0.1);
        	windowFTL.position.x = -4.03;
        	windowFTL.position.y = 0.75;
        	windowFTL.position.z = 0.1;
        	
        	var windowFTR = windowMaker(1.9, 1.8, 2, 0.15, 0.1);
        	windowFTR.position.x = 2.13;
        	windowFTR.position.y = 0.75;
        	windowFTR.position.z = 0.1;
        	
        	var windowFTM = windowMaker(1.3, 1.8, 2, 0.15, 0.1);
        	windowFTM.position.x = -0.65;
        	windowFTM.position.y = 0.75;
        	windowFTM.position.z = 0.1;
        	
        	var windowRBL = windowMaker(3.15, 1.5, 4, 0.15, 0.1);
        	windowRBL.position.x = -5;
        	windowRBL.position.y = -1.8;
        	windowRBL.position.z = 9;
        	
        	var windowRBR = windowMaker(1.7, 1.5, 2, 0.15, 0.1);
        	windowRBR.position.x = -0.8;
        	windowRBR.position.y = -1.8;
        	windowRBR.position.z = 9;
        	
        	var windowRTL = windowMaker(3.15, 1.8, 4, 0.15, 0.1);
        	windowRTL.position.x = -5;
        	windowRTL.position.y = 0.75;
        	windowRTL.position.z = 9;
        	
        	var windowRTR = windowMaker(1.3, 0.8, 1, 0.15, 0.1);
        	windowRTR.position.x = -0.6;
        	windowRTR.position.y = 1.75;
        	windowRTR.position.z = 9;
        	
        	var windowR1BL = windowMaker(0.8, 1.5, 1, 0.15, 0.1);
        	windowR1BL.position.x = 3.7;
        	windowR1BL.position.y = -1.8;
        	windowR1BL.position.z = 6;
        	
        	var windowR1TL = windowMaker(0.8, 1.8, 1, 0.15, 0.1);
        	windowR1TL.position.x = 1.9;
        	windowR1TL.position.y = 0.75;
        	windowR1TL.position.z = 6;
        	
        	var windowR1TR = windowMaker(0.8, 1.8, 1, 0.15, 0.1);
        	windowR1TR.position.x = 4.2;
        	windowR1TR.position.y = 0.75;
        	windowR1TR.position.z = 6;


            var doorMaker = function(width, height, depth) {
        		var doorShape = [
        			new BABYLON.Vector3(0, 0, 0),
        			new BABYLON.Vector3(width, 0, 0),
        			new BABYLON.Vector3(width, 0, height),
        			new BABYLON.Vector3(0, 0, height)
        		];
        		edgeThickness = width/8
        		var panelWidth = width - 2 * edgeThickness;	
        		var panelBotHeight = (height - 3 * edgeThickness)/1.75;
        		var panelTopHeight = 0.75 * panelBotHeight;
        		var panel = [];
        		panel[0] = [];
        		panel[0].push(new BABYLON.Vector3(edgeThickness, 0, 2*edgeThickness + panelBotHeight));
        		panel[0].push(new BABYLON.Vector3(edgeThickness + panelWidth, 0, 2 * edgeThickness + panelBotHeight));
        		panel[0].push(new BABYLON.Vector3(edgeThickness + panelWidth, 0, 2 * edgeThickness + panelBotHeight + panelTopHeight));
        		panel[0].push(new BABYLON.Vector3(edgeThickness, 0, 2 * edgeThickness + panelBotHeight + panelTopHeight));
        		panel[1] = [];
        		panel[1].push(new BABYLON.Vector3(edgeThickness, 0, edgeThickness));
        		panel[1].push(new BABYLON.Vector3(edgeThickness + panelWidth, 0, edgeThickness));
        		panel[1].push(new BABYLON.Vector3(edgeThickness + panelWidth, 0, edgeThickness + panelBotHeight));
        		panel[1].push(new BABYLON.Vector3(edgeThickness, 0, edgeThickness + panelBotHeight));
        		var door = BABYLON.MeshBuilder.ExtrudePolygon("door", {shape:doorShape, holes: panel, depth: depth}, scene);
        		door.rotation.x = -Math.PI/2;
        		var panelB = BABYLON.MeshBuilder.CreateBox("p1b", {width: panelWidth, height: panelBotHeight, depth: depth/2}, scene);
        		panelB.position.x = edgeThickness + panelWidth/2;
        		panelB.position.y = edgeThickness + panelBotHeight/2;
        		panelB.position.z = depth/2;
        		var panelT = BABYLON.MeshBuilder.CreateBox("p1t", {width: panelWidth, height: panelTopHeight, depth: depth/2}, scene);
        		panelT.position.x = edgeThickness + panelWidth/2;
        		panelT.position.y = 2*edgeThickness + panelBotHeight + panelTopHeight/2;
        		panelT.position.z = depth/2;
        		
        		return BABYLON.Mesh.MergeMeshes([door, panelB, panelT], true);
        	};
        	
        	var doormat = new BABYLON.StandardMaterial("door", scene);
        	doormat.diffuseColor = new BABYLON.Color3(82/255, 172/255, 106/255);
        	
        	var frontDoor = doorMaker(1, 2.25, 0.1, 0.05);
        	frontDoor.position.x = -0.5;
        	frontDoor.position.y = -3;
        	frontDoor.position.z = 0.1;
        	frontDoor.material = doormat;
        	
        	var backDoor = doorMaker(1, 2.25, 0.1, 0.05);
        	backDoor.rotation.y = Math.PI/2;
        	backDoor.position.x = 1.3;
        	backDoor.position.y = -3;
        	backDoor.position.z = 8.65;
        	backDoor.material = doormat;















    
    var shapeBox = [ 
                  new BABYLON.Vector3(0, 0, 0),
                  new BABYLON.Vector3(3, 0, 0), 
                  new BABYLON.Vector3(3, 0, 3), 
                  new BABYLON.Vector3(0, 0, 3), 

            ];
    var shapeTri = [ 
                  new BABYLON.Vector3(0, 0, 0),
                  new BABYLON.Vector3(6, 0, 0), 
                  new BABYLON.Vector3(3, 0, 5), 

            ];


    var shapeTrueBox = [ 
                  new BABYLON.Vector3(0, 0, 0),
                  new BABYLON.Vector3(5, 0, 0), 
                  new BABYLON.Vector3(5, 0, 5), 
                  new BABYLON.Vector3(0, 0, 5), 

            ];
    var shapeTrueTri = [ 
                  new BABYLON.Vector3(0, 0, 0),
                  new BABYLON.Vector3(8, 0, 0), 
                  new BABYLON.Vector3(4, 0, 7), 

            ];
                
    var faceColors = [];
        faceColors[0] = BABYLON.Color3.Red();
        faceColors[1] = BABYLON.Color3.Red();
        faceColors[2] = BABYLON.Color3.Red();
        faceColors[3] = BABYLON.Color3.Red();
        faceColors[4] = BABYLON.Color3.Red();
        faceColors[5] = BABYLON.Color3.Red();
   
    var trueFaceColors = [];
        trueFaceColors[0] = BABYLON.Color3.Green();
        trueFaceColors[1] = BABYLON.Color3.Green();
        trueFaceColors[2] = BABYLON.Color3.Green();
        trueFaceColors[3] = BABYLON.Color3.Green();
        trueFaceColors[4] = BABYLON.Color3.Green();
        trueFaceColors[5] = BABYLON.Color3.Green();
        
    var redColors = [];
        redColors[0] = BABYLON.Color3.Red();
        redColors[1] = BABYLON.Color3.Red();
        redColors[2] = BABYLON.Color3.Red();
        redColors[3] = BABYLON.Color3.Red();
        redColors[4] = BABYLON.Color3.Red();
        redColors[5] = BABYLON.Color3.Red();
    var blueColors = [];
        blueColors[0] = BABYLON.Color3.Blue();
        blueColors[1] = BABYLON.Color3.Blue();
        blueColors[2] = BABYLON.Color3.Blue();
        blueColors[3] = BABYLON.Color3.Blue();
        blueColors[4] = BABYLON.Color3.Blue();
        blueColors[5] = BABYLON.Color3.Blue();  
    var greenColors = [];
        greenColors[0] = BABYLON.Color3.Green();
        greenColors[1] = BABYLON.Color3.Green();
        greenColors[2] = BABYLON.Color3.Green();
        greenColors[3] = BABYLON.Color3.Green();
        greenColors[4] = BABYLON.Color3.Green();
        greenColors[5] = BABYLON.Color3.Green();

    //Box的判定区域        
    // var trueBox = BABYLON.MeshBuilder.ExtrudePolygon("trueBox",{shape:shapeTrueBox, depth: 0.01, faceColors:redColors, sideOrientation: BABYLON.Mesh.DOUBLESIDE,faceColors:redColors }, scene);
    
    // trueBox.setAbsolutePosition(-10,0.2,-8);

    // //Tri的判定区域
    // var trueTri = BABYLON.MeshBuilder.ExtrudePolygon("trueTri", {shape:shapeTrueTri, depth: 0.01,faceColors:blueColors, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
   
    // trueTri.setAbsolutePosition(-4,0.2,-1);

    // //Cir的判定区域
    // var trueCir = BABYLON.MeshBuilder.CreateCylinder("trueCir", {height:0.01,diameter: 5.5, tessellation: 99, faceColors:greenColors}, scene);

    // trueCir.setAbsolutePosition(8,0.2,-6);

    var trueLine = [
        new BABYLON.Vector3(-1, 0, -1), 
        new BABYLON.Vector3(13, 0, -1), 
        new BABYLON.Vector3(13, 0, 13), 
        new BABYLON.Vector3(-1, 0, 13),
    ]; 
    
    var trueLineHoles = [];
              
    // trueLineHoles[0] = [
    //     new BABYLON.Vector3(0, 0, 0), 
    //     new BABYLON.Vector3(12, 0, 0), 
        
    //     new BABYLON.Vector3(11, 0, 1), 
    //     new BABYLON.Vector3(1, 0, 1),           
    //     ]; 
    // trueLineHoles[1] = [
    //     new BABYLON.Vector3(0, 0, 0), 
    //     new BABYLON.Vector3(1, 0, 1),

    //     new BABYLON.Vector3(1, 0, 11), 
    //     new BABYLON.Vector3(0, 0, 12),           
    //     ]; 
    // trueLineHoles[2] = [
    //     new BABYLON.Vector3(1, 0, 11), 
    //     new BABYLON.Vector3(11, 0, 11),

    //     new BABYLON.Vector3(12, 0, 12), 
    //     new BABYLON.Vector3(0, 0, 12),           
    //     ];
    // trueLineHoles[3] = [
    //     new BABYLON.Vector3(11, 0, 1), 
    //     new BABYLON.Vector3(12, 0, 0),

    //     new BABYLON.Vector3(12, 0, 12), 
    //     new BABYLON.Vector3(11, 0, 11),           
    //     ];
    
    trueLineHoles[0] = [
        new BABYLON.Vector3(0, 0, 0), 
        new BABYLON.Vector3(12, 0, 0), 
        
        new BABYLON.Vector3(12, 0, 1), 
        new BABYLON.Vector3(0, 0, 1),           
        ]; 
    trueLineHoles[1] = [
        new BABYLON.Vector3(0, 0, 1), 
        new BABYLON.Vector3(1, 0, 1),

        new BABYLON.Vector3(1, 0, 11), 
        new BABYLON.Vector3(0, 0, 11),           
        ]; 
    trueLineHoles[2] = [
        new BABYLON.Vector3(0, 0, 11), 
        new BABYLON.Vector3(12, 0, 11),

        new BABYLON.Vector3(12, 0, 12), 
        new BABYLON.Vector3(0, 0, 12),           
        ];
    trueLineHoles[3] = [
        new BABYLON.Vector3(11, 0, 1), 
        new BABYLON.Vector3(12, 0, 1),

        new BABYLON.Vector3(12, 0, 11), 
        new BABYLON.Vector3(11, 0, 11),           
        ];

    var leftSide=[
        new BABYLON.Vector3(0, 0, 0),
        new BABYLON.Vector3(4, 0, 0),
        new BABYLON.Vector3(4, 0, 4),
        new BABYLON.Vector3(0, 0, 4),
        new BABYLON.Vector3(2, 5, 2),
        
    ];

   
    
    // var trueLine1 = BABYLON.MeshBuilder.ExtrudePolygon("trueLine1",{shape:trueLine, holes:trueLineHoles,  depth: 0.2, faceColors:redColors, sideOrientation: BABYLON.Mesh.DOUBLESIDE,faceColors:redColors }, scene);
    // trueLine1.setAbsolutePosition(new BABYLON.Vector3(-6, 0.1, -6));

    // var leftSide = BABYLON.MeshBuilder.ExtrudePolygon("leftSide",{shape:leftSide,sideOrientation: BABYLON.Mesh.DOUBLESIDE,depth:2,faceColors:redColors }, scene);

    //设置skybox
    // var skybox = BABYLON.Mesh.CreateBox("skyBox", 100.0, scene);
    // var skyboxMaterial = new BABYLON.StandardMaterial("../skyBox", scene);
    // skyboxMaterial.backFaceCulling = false;
    // skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("../skyBox/3", scene);
    // skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    // skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
    // skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
    // skyboxMaterial.disableLighting = true;
    // skybox.material = skyboxMaterial;


    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("ui1");

    var createLabel = function(mesh) {
        
        var label = new BABYLON.GUI.Rectangle("label for " + mesh.name);
        
        label.background = "white"
        label.height = "30px";
        label.alpha = 0.5;
        label.width = "70px";
        label.height = "30px";

        label.cornerRadius = 20;
        label.thickness = 1;
        label.linkOffsetY = 30;
        
        advancedTexture.addControl(label); 
        label.linkWithMesh(mesh);

        var text1 = new BABYLON.GUI.TextBlock();
        text1.text = mesh.id;
        text1.color = "black";
        label.addControl(text1);  
    }  

    // createLabel(trueBox);
    // createLabel(trueTri);
    // createLabel(trueCir);














    
    //实际场地长宽
    var realWidth=4.1;
    var realHeihgt=4.1;
    //长宽缩放的尺度
    var scaleW=30/realWidth;
    var scaleH=25/realHeihgt;
    
    var box;


    //计算转换矩阵
    var matrix = BABYLON.Matrix.Compose(
      
        new BABYLON.Vector3(scaleW,1,scaleH),//需要变动的就是x z 轴的比例，要根据 交互区域 与平面的大小决定每个方向上的缩放比例
        
        BABYLON.Quaternion.Identity(),//旋转矩阵，暂不考虑，为单位阵
        
        new BABYLON.Vector3(0,0,0),//平移向量，构建平移矩阵
    
    );

 

    
    //创建新的mesh
    var time=0;
    function createShape(id,pos)//创建新的mesh
            {
                var i=id.toString();
                

                // box = BABYLON.MeshBuilder.CreateBox(i,scene);
                // box.state="box";
                // box.position = BABYLON.Vector3.TransformCoordinates(pos, matrix);

                if(time==0)
                {
                    var box = BABYLON.MeshBuilder.ExtrudePolygon(i,{shape:shapeBox, depth: 0.1,faceColors:faceColors, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
                    box.state="box"
                    time=1;
                }
                else if(time==1)
                {
                    var tri = BABYLON.MeshBuilder.ExtrudePolygon(i, {shape:shapeTri,  depth: 0.1,faceColors:faceColors, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
                    tri.state="tri";
                    time=2;
                }
                else if(time==2)
                {
                    var cir = BABYLON.MeshBuilder.CreateCylinder(i, {height:0.1,diameterTop: 1, diameter:3,tessellation: 99, faceColors:faceColors}, scene);
                                        
                    cir.state="cir";
                    time=0
                }
                else{
                    alert("error in creating");
                }
                
                console.log("Create");
            }
    
    //更新已有mesh的位置
    function changePos(id,pos)
            {
                var m = scene.getMeshByID(id.toString());
                
                m.setAbsolutePosition(BABYLON.Vector3.TransformCoordinates(pos, matrix));
                
                console.log("Change");

            }
    
    //删除不再更新的mesh
    function disposePos(ids)
    {
        
        for(var i=0;i<ids.length;i++)
        {
           var m = scene.getMeshByID(ids[i].toString());
           
           
            
            console.log("Dispose");

            // m.isVisible=false;
            m.dispose();

            var index = shapes.indexOf(ids[i]);
            if (index > -1) {
                    shapes.splice(index, 1);
                }
            
        }
        
    }


    //比较两个数组的不同
    function getArrDifference(arr1, arr2) {
        
        if(arr1.length!=0&&arr2.length!=0)
        {
            return arr1.concat(arr2).filter(function(v, i, arr) {
        
                return arr.indexOf(v) === arr.lastIndexOf(v);

        
            });
        }
        else{
            var a=[];
            return a;
        }
    }
   
            
            
    function afterJudge(id)
    {
        var i= id;
        var m = scene.getMeshByID(id);
        var s=m.state;
        
        //m.isVisible=false;
       
        m.dispose();

        var t = Date.now();
        
        function sleep(d){
            while(Date.now - t <= d);
        } 
        sleep(1000);
         
        if(s=="box")
        {
            m=BABYLON.MeshBuilder.ExtrudePolygon(i, {shape:shapeTri,  depth: 0.1,faceColors:faceColors, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            
            m.state="tri";

        }
        else if(s=="tri")
        {
             m=BABYLON.MeshBuilder.CreateCylinder(i, {height:0.1,diameterTop: 1, tessellation: 99, faceColors:faceColors}, scene);

             m.state="cir";

        }
        else if(s=="cir")
        {
            m=BABYLON.MeshBuilder.ExtrudePolygon(i, {shape:shapeBox,  depth: 0.1,faceColors:faceColors, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);

            m.state="box";

        }
        else
        {
            alert("judge after error")
        }




    }




    //判断函数，既要判断位置，还要判断形状
    function judge(id)
    {
        var m = scene.getMeshByID(id);
        var pos = m.getAbsolutePosition();
        var s=m.state;
        var t=[];



        
        if(s=="box")
        {
            if(Math.abs(m.position.x- (-10)) <= 0.8 && Math.abs(m.position.z- (-8)) <= 0.8)
            {

                console.log("boxxxx");
                afterJudge(id);
                

                
            }


        }
        else if(s=="tri")
        {
            if(Math.abs(m.position.x- (-4)) <= 0.8 && Math.abs(m.position.z- (-1)) <= 0.8)
            {

                console.log("triiii");
                afterJudge(id);

                

            }
        }
        else if(s=="cir")
        {
            if(Math.abs(m.position.x- (8)) <= 0.8 && Math.abs(m.position.z- (-6)) <= 0.8)
            {

                console.log("cirrrr");
                afterJudge(id);

               
            }
        }
        else
        {
            alert("judge error")
        }

    }

    















    //获取当前场景中所有mesh的id
    function getAllmeshid()
    {
        
        // if(scene.meshes.length>10)
        // {
        //     for (var i = 11; i < scene.meshes.length; i++) {
                        
        //                 shapes.push(parseInt(scene.meshes[i].id));
                        
        //             } 
        // }
  

        //改进算法

            for (var i = 0; i < scene.meshes.length; i++) {
                
                var m=scene.meshes[i];
                
                if(m.state=="box"||m.state=="box"||m.state=="box")
                {  
                    shapes.push(parseInt(scene.meshes[i].id));
                }
                else
                {
                    console.log(m);
                }       
            } 
        

    }




    
    

    var shapes=[];//存储当前的场景中的mesh的id
    
    var s=[];//存储本次输入的id

    var diff =[];//比较二者的不同

    up = function updateStats(memuse) {
        
      var i;


      for (i in memuse.tracks) {
        

        if (memuse.tracks[i].x >= -2 && memuse.tracks[i].x <= 2 && memuse.tracks[i].y >= -2 && memuse.tracks[i]
          .y <= 2) {

            var z = memuse.tracks[i]["x"];
            var x = memuse.tracks[i]["y"];
            var h = memuse.tracks[i]["height"];
            var color = memuse.tracks[i]["confidence"];
            var id = memuse.tracks[i]["id"];
            
            s.push(id);

            var local_pos = new BABYLON.Vector3(x, 0.5, -z);

            
            getAllmeshid()

            if(shapes.indexOf(id)==-1)//id在场景数组中不存在,添加新的对象
            {

                createShape(id,local_pos);    
                
            }

            else//该id在现有场景数组中存在，更新其位置
            {
                changePos(id.toString(),local_pos);
                
                judge(id.toString());
                
            }

            shapes=[];
          }
        }  
        
        getAllmeshid()


        //场景数组中存在，但传入数据不存在，停止对其位置更新
        diff = getArrDifference(shapes,s);
        
        if(diff.length!=0)
        {
           disposePos(diff);
        }
       //console.log(s);

       s=[];
       shapes=[];
       

    }

 //   var music = new BABYLON.Sound("Music", "../audio/win.mp3", scene, null, { loop: true, autoplay: true });


//    var music = new BABYLON.Sound("music", "../audio/win.mp3",scene, null, { loop: true, autoplay: true, spatialSound: true });






        //box.rotate(BABYLON.Axis.Y, Math.PI / 150, BABYLON.Space.LOCAL);
        //box.rotate(BABYLON.Axis.X, Math.PI / 200, BABYLON.Space.LOCAL);
       
        //box.translate(new BABYLON.Vector3(-1, -1, -1).normalize(), 0.001, BABYLON.Space.WORLD)
        
        //small.rotationQuaternion = box.rotationQuaternion;
        //matrix = box.getWorldMatrix();
        // y += 0.001;
        // local_pos = new BABYLON.Vector3(1, 0, 1);



       // box.position = BABYLON.Vector3.TransformCoordinates(local_pos, matrix);


   
   
   /****************************************************************/

    // show axis
    var showAxis = function (size) {
        var makeTextPlane = function (text, color, size) {
            var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
            dynamicTexture.hasAlpha = true;
            dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color, "transparent", true);
            var plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
            plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
            plane.material.backFaceCulling = false;
            plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
            plane.material.diffuseTexture = dynamicTexture;
            return plane;
        };

        var axisX = BABYLON.Mesh.CreateLines("axisX", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),
            new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
        ], scene);
        axisX.color = new BABYLON.Color3(1, 0, 0);
        var xChar = makeTextPlane("X", "red", size / 10);
        xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);
        var axisY = BABYLON.Mesh.CreateLines("axisY", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),
            new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)
        ], scene);
        axisY.color = new BABYLON.Color3(0, 1, 0);
        var yChar = makeTextPlane("Y", "green", size / 10);
        yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);
        var axisZ = BABYLON.Mesh.CreateLines("axisZ", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, -0.05 * size, size * 0.95),
            new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, 0.05 * size, size * 0.95)
        ], scene);
        axisZ.color = new BABYLON.Color3(0, 0, 1);
        var zChar = makeTextPlane("Z", "blue", size / 10);
        zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
    };

    //Local Axes
    function localAxes(size) {
        var pilot_local_axisX = BABYLON.Mesh.CreateLines("pilot_local_axisX", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),
            new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
        ], scene);
        pilot_local_axisX.color = new BABYLON.Color3(1, 0, 0);

        pilot_local_axisY = BABYLON.Mesh.CreateLines("pilot_local_axisY", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),
            new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)
        ], scene);
        pilot_local_axisY.color = new BABYLON.Color3(0, 1, 0);

        var pilot_local_axisZ = BABYLON.Mesh.CreateLines("pilot_local_axisZ", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, -0.05 * size, size * 0.95),
            new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, 0.05 * size, size * 0.95)
        ], scene);
        pilot_local_axisZ.color = new BABYLON.Color3(0, 0, 1);

        var local_origin = BABYLON.MeshBuilder.CreateBox("local_origin", { size: 1 }, scene);
        local_origin.isVisible = false;

        pilot_local_axisX.parent = local_origin;
        pilot_local_axisY.parent = local_origin;
        pilot_local_axisZ.parent = local_origin;

        return local_origin;

    }

    showAxis(4);
    
    
    return scene;
};

        scene=createScene();//调用函数
        
        //注册一个重复渲染场景
        engine.runRenderLoop(function(){
            scene.render();
        })

          // 监测浏览器/画布大小改变事件
        window.addEventListener("resize",function()
        {
            engine.resize();
        })


    </script>

<script>
    
    //websocket 传输数据
    var ws = new WebSocket('ws://' + '192.168.1.5' + ':3030');
    ws.onopen = function () {
      //alert("open WebSocket on server");
    };

    ws.onmessage = function (evt) {
    //   if (tf_a == 0) {
    //     getWidth(JSON.parse(evt.data));
    //   }

    up(JSON.parse(evt.data));


    
    };

    ws.onclose = function () {
      // websocket is closed.
      //alert("Connection is closed...");
    };






</script>

</body>
</html>